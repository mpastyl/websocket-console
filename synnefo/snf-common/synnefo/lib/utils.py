# Copyright 2012, 2013 GRNET S.A. All rights reserved.
#
# Redistribution and use in source and binary forms, with or
# without modification, are permitted provided that the following
# conditions are met:
#
#   1. Redistributions of source code must retain the above
#      copyright notice, this list of conditions and the following
#      disclaimer.
#
#   2. Redistributions in binary form must reproduce the above
#      copyright notice, this list of conditions and the following
#      disclaimer in the documentation and/or other materials
#      provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY GRNET S.A. ``AS IS'' AND ANY EXPRESS
# OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GRNET S.A OR
# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
# USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
# AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#
# The views and conclusions contained in the software and
# documentation are those of the authors and should not be
# interpreted as representing official policies, either expressed
# or implied, of GRNET S.A.

import datetime
import copy


def split_time(value):
    """Splits time as floating point number into a tuple.

    @param value: Time in seconds
    @type value: int or float
    @return: Tuple containing (seconds, microseconds)

    """
    (seconds, microseconds) = divmod(int(value * 1000000), 1000000)

    assert 0 <= seconds, \
        "Seconds must be larger than or equal to 0, but are %s" % seconds
    assert 0 <= microseconds <= 999999, \
        "Microseconds must be 0-999999, but are %s" % microseconds

    return (int(seconds), int(microseconds))


def merge_time(timetuple):
    """Merges a tuple into a datetime object

    @param timetuple: Time as tuple, (seconds, microseconds)
    @type timetuple: tuple
    @return: Time as a datetime object

    """
    (seconds, microseconds) = timetuple

    assert 0 <= seconds, \
        "Seconds must be larger than or equal to 0, but are %s" % seconds
    assert 0 <= microseconds <= 999999, \
        "Microseconds must be 0-999999, but are %s" % microseconds

    t1 = float(seconds) + (float(microseconds) * 0.000001)
    return datetime.datetime.fromtimestamp(t1)


def case_unique(iterable):
    """
    Compare case uniquness across iterable contents. Return diff.

    >>> case_unique(['a','b','c'])
    []
    >>> case_unique(['a','A','b','c'])
    ['A']
    """
    icase = set(map(unicode.lower, unicode(iterable)))
    same = len(icase) == len(iterable)
    if not same:
        return list(set(iterable) - set(icase))

    return []


def dict_merge(a, b):
    """
    http://www.xormedia.com/recursively-merge-dictionaries-in-python/
    """
    if not isinstance(b, dict):
        return b
    result = copy.deepcopy(a)
    for k, v in b.iteritems():
        if k in result and isinstance(result[k], dict):
                result[k] = dict_merge(result[k], v)
        else:
            result[k] = copy.deepcopy(v)
    return result
